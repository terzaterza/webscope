import { Decoder, DecoderMetadata } from "./Decoder";
import { ParameterMap, ParameterValues } from "./Parameter";
import { objectMap } from "./Util";
import { Waveform, WaveformType } from "./Waveform";

type StreamOutputType   = { [ch: string]: WaveformType };
type StreamOutput       = { [ch: string]: Waveform };

/**
 * Base class (interface) for all streams which
 * calls the registered callback once more data is available
 */
export abstract class WaveformStream {

    /**
     * @param outputType Waveform types generated by this stream
     * @param dataReadyCallback To be used by stream implementation when acquired new data
     * @todo Add generic WaveformStream<T extends WaveformType>
     * @todo Make outputType private and add a getter
     */
    constructor(public readonly outputType: StreamOutputType) {}

    /**
     * Start data acquisition
     * 
     * This is called by the session after the callback has been
     * assigned and the stream instance has been created and setup
     */
    // public abstract start(): void;

    /**
     * Used by the Session object to set the callback
     * for updating the data of the correct waveform instance
     */
    public setCallback(callback: (data: StreamOutput) => void): void {
        this.dataReadyCallback = callback;
    }

    /**
     * Call from derived stream class once the
     * raw data has been converted to a waveform
     */
    protected onWaveformReady(data: StreamOutput): void {
        /** @todo Verify that data is actually of data type */
        
        console.assert(Object.entries(data).every(
            ([ch, waveform]) => waveform.dataType === this.outputType[ch])
        );

        if (this.dataReadyCallback)
            this.dataReadyCallback(data);
    }

    private dataReadyCallback?: (data: StreamOutput) => void;

}

/**
 * Stream which takes in a decoder instance and on input
 * waveform update it triggers the decoding
 */
export class DecoderWaveformStream extends WaveformStream {

    constructor(private decoder: Decoder<DecoderMetadata>) {
        super(objectMap(decoder.metadata.output, (k, v) => v.dataType));
        
        this.parameters = objectMap(decoder.metadata.params, (k, v) => v.default);
    }

    /**
     * 
     */
    // public decode(input: , params) {

    // }

    private parameters: ParameterValues<ParameterMap>;
            
    // @todo Add decoders for modulation like PSK, QAM, ...
}

/**
 * Stream which takes in a text input and parses it
 * @note Currently supports only one channel
 */
export class TextDelimitedStream extends WaveformStream {

    constructor(
        dataType: WaveformType,
        private text: string,
        private delimiter: string
    ) {
        super({"CH1": dataType});
    }
    
    public start(): void {
        const waveform = TextDelimitedStream.parseText(
            this.text,
            this.delimiter,
            this.outputType["CH1"]
        );

        this.onWaveformReady({"CH1": waveform});
    }
    
    public static parseText(text: string, delimiter: string, dataType: WaveformType): Waveform {
        const samplesRaw = text.split(delimiter);
        switch (dataType) {
            case "analog": return {
                dataType: "analog",
                data: samplesRaw.map((v) => parseFloat(v)),
                sampleRate: 1
            };
            case "binary": return {
                dataType: "binary",
                data: samplesRaw.map((v) => (v === "1" ? 1 : 0)),
                sampleRate : 1
            };
            case "frame": throw new Error("Frame waveforms not supported");
        }
    }
}

// export class FileWaveformStream extends WaveformStream {
    
//     public readFile(file: File) {
//         // can also use TextDelimitedStream.parseText
//     }
// }

// export class SerialPortWaveformStream extends WaveformStream {
//     // private port: SerialPort;
// }

// export class NetworkWaveformStream extends WaveformStream {
//     // private websocket: WebSocket
// }